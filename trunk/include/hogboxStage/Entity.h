#pragma once

#include <hogboxStage/Export.h>
#include <hogbox/HogBoxBase.h>
#include <hogboxStage/Component.h>
#include <hogboxStage/RenderableComponent.h>

namespace hogboxStage 
{

//
//Entity
//
//Entity 
//Consists of a collection of components
//Only one type of each component can exist in a single entity
//the main systems e.g. collision system, check each entity
//for wheather or not they have a corresonding compnent e.g. collision component
//and if so call its update accordingly
//If for example and entity is involved in a collision
//then its OnCollide event would be triggered ?
//
class HOGBOXSTAGE_EXPORT Entity : public osg::Object
{
public:

	typedef std::map<std::string, ComponentPtr> ComponentMap;
	typedef std::pair<std::string, ComponentPtr> ComponentPair;

	Entity(bool isProcedural=false)
		: osg::Object(),
		m_isProcedural(isProcedural)
	{
	}

	/** Copy constructor using CopyOp to manage deep vs shallow copy.*/
	Entity(const Entity& ent,const osg::CopyOp& copyop=osg::CopyOp::SHALLOW_COPY)
		: osg::Object(ent, copyop)
	{
	}

	META_Box(hogboxStage, Entity);

	//
	//Add a new component, returns false if component of same type
	//already exists
	bool AddComponent(Component* comp){
		//check if the component type already exists
		if(!GetComponentOfType(comp->GetTypeName())){
			ComponentPair newComponent(comp->GetTypeName(), comp);
			return true;
		}
		return false;
	}

	//
	//Remove a component my type name, returns false if
	//no component of that type exists
	bool RemoveComponentOfType(std::string componentType){
		ComponentMap::const_iterator itr = _components.find(componentType);
		if(itr!=_components.end()){
			//(*itr).second = NULL;
			_components.erase(itr);
			return true;
		}
		return false;
	}
	
	//
	//returns null if the component type does not exist in the map
	Component* GetComponentOfType(std::string componentType){
		ComponentMap::iterator itr = _components.find(componentType);
		if(itr!=_components.end()){return (*itr).second.get();}
		return NULL;
	}

	//
	//Get or create a component of the passed template type
	//used by other components that require the entity have certain
	//other types of component e.g. a movments component would require
	//a world transform component
	template<class T>
	T* GetOrCreateComponentOfType(){
		ComponentMap::iterator itr = _components.begin();
		for( ;itr!=_components.end();itr++){
			//try to cast the component to the correct type
			T* castType = dynamic_cast<T*>((*itr).second.get());
			if(castType){return castType;}
		}
		//didn't find one so create and add one
		T* newComponent = new T();
		AddComponent(newComponent);
		return newComponent;
	}

protected:

	virtual ~Entity(void) {

	}

	//
	//Our main update function 
	virtual bool OnUpdate(void* update){return true;}

protected:

	//has the entity been generated by code (ture) or loaded
	//from xml (false)
	bool m_isProcedural;

	//map of components referenced by component type name
	ComponentMap _components;

};
typedef osg::ref_ptr<Entity> EntityPtr;

};